import json
import os
import sys
from base64 import b64decode, b64encode
from uuid import uuid4

import click

from . import libprio


def apply_options(func, options):
    for option in options:
        func = option(func)
    return func


def public_key(func):
    options = [
        click.option(
            "--public-key-internal",
            required=True,
            type=str,
            help="The public key of the processing server.",
        ),
        click.option(
            "--public-key-external",
            required=True,
            type=str,
            help="The public key of the co-processing server.",
        ),
    ]
    return apply_options(func, options)


def server_config(func):
    options = [
        click.option(
            "--server-id",
            required=True,
            type=click.Choice(["A", "B"]),
            help="The identifier for match.",
        ),
        click.option(
            "--private-key",
            required=True,
            type=str,
            help="The private key of the processing server.",
        ),
        click.option(
            "--shared-secret",
            required=True,
            type=str,
            help="The shared server secret encoded in base64.",
        ),
    ]
    return apply_options(func, options)


def output_1(func):
    options = [
        click.option(
            "--output",
            required=True,
            type=click.Path(file_okay=False),
            help="The path to the output directory.",
        )
    ]
    return apply_options(func, options)


def output_2(func):
    options = [
        click.option(
            "--output-A",
            required=True,
            type=click.Path(file_okay=False),
            help="The path to the input directory of server A.",
        ),
        click.option(
            "--output-B",
            required=True,
            type=click.Path(file_okay=False),
            help="The path to the input directory of server B.",
        ),
    ]
    return apply_options(func, options)


def input_1(func):
    options = [
        click.option(
            "--input",
            required=True,
            type=click.Path(dir_okay=False),
            help="File containing shares from clients.",
        )
    ]
    return apply_options(func, options)


def input_2(func):
    options = [
        click.option(
            "--input-internal",
            required=True,
            type=click.Path(dir_okay=False),
            help="File containing data generated by the processing server.",
        ),
        click.option(
            "--input-external",
            required=True,
            type=click.Path(dir_okay=False),
            help="File containing data generated by the co-processing server.",
        ),
    ]
    return apply_options(func, options)


def data_config(func):
    options = [
        click.option(
            "--batch-id",
            required=True,
            type=str,
            help="A shared batch identifier used as a validity check.",
        ),
        click.option(
            "--n-data",
            required=True,
            type=int,
            help="The size of the input bit-vector.",
        ),
    ]
    return apply_options(func, options)


@click.command()
def shared_seed():
    """Generate a shared server secret in base64."""
    seed = libprio.PrioPRGSeed_randomize()
    click.echo(b64encode(seed))


@click.command()
def keygen():
    """Generate a curve25519 key pair as json."""
    private, public = libprio.Keypair_new()
    private_hex = libprio.PrivateKey_export_hex(private).decode("utf-8")[:-1]
    public_hex = libprio.PublicKey_export_hex(public).decode("utf-8")[:-1]
    data = json.dumps({"private_key": private_hex, "public_key": public_hex})
    click.echo(data)


@click.command()
@data_config
@public_key
@input_1
@output_2
def encode_shares(
    batch_id,
    n_data,
    public_key_internal,
    public_key_external,
    input,
    output_a,
    output_b,
):
    public_key_internal = libprio.PublicKey_import_hex(
        bytes(public_key_internal, "utf-8")
    )
    public_key_external = libprio.PublicKey_import_hex(
        bytes(public_key_external, "utf-8")
    )
    batch_id = bytes(batch_id, "utf-8")

    config = libprio.PrioConfig_new(
        n_data, public_key_internal, public_key_external, batch_id
    )

    data = []
    with open(input, "r") as f:
        for line in f.readlines():
            data.append(json.loads(line))

    name = os.path.basename(input)
    path_a = os.path.join(output_a, name)
    path_b = os.path.join(output_b, name)
    with open(path_a, "w") as fp_a, open(path_b, "w") as fp_b:
        for datum in data:
            share_a, share_b = libprio.PrioClient_encode(config, bytes(datum))
            json.dump(
                {"id": str(uuid4()), "payload": b64encode(share_a).decode()}, fp_a
            )
            json.dump(
                {"id": str(uuid4()), "payload": b64encode(share_b).decode()}, fp_b
            )


@click.command()
@data_config
@server_config
@public_key
@input_1
@output_2
def verify1():
    """Decode a batch of shares"""
    click.echo("Running verify1")


@click.command()
@data_config
@server_config
@public_key
@input_2
@output_1
def verify2():
    """Verify a batch of SNIPs"""
    click.echo("Running verify2")


@click.command()
@data_config
@server_config
@public_key
@input_2
@output_1
def aggregate():
    """Generate an aggregate share from a batch of verified SNIPs"""
    click.echo("Running aggregate")


@click.command()
@data_config
@server_config
@public_key
@input_2
@output_1
def publish():
    """Generate a final aggregate and remap data to a content blocklist"""
    click.echo("Running publish")


@click.group()
def main(args=None):
    """Command line utility for prio."""
    pass


main.add_command(shared_seed)
main.add_command(keygen)

main.add_command(encode_shares)
main.add_command(verify1)
main.add_command(verify2)
main.add_command(aggregate)
main.add_command(publish)

if __name__ == "__main__":
    sys.exit(main())
